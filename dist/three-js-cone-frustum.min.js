var THREEConeFrustum=function(t,e){"use strict";function s(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var i=s(e);i.default.Ray.prototype.intersectsConeFrustum=function(){const t=new i.default.Vector3,e=new i.default.Vector3,s=new i.default.Vector3;return function(i,a){null==a&&(a=e);const o=i.radius1-i.radius0,r=1+Math.pow(o/i.height,2),n=i.radius0*o/i.height;t.subVectors(this.origin,i.base);const c=t.dot(i.axis),h=t.dot(t),u=this.direction.dot(i.axis),d=this.direction.dot(t),l=this.direction.dot(this.direction),p=i.radius0*i.radius0+2*n*c+r*c*c-h,x=n*u+r*c*u-d,g=r*u*u-l;if(0!==g){const o=x*x-g*p;if(o<0)return null;if(0!==o){let r=0;const n=Math.sqrt(o),c=(-x-n)/g;s.copy(t),s.addScaledVector(this.direction,c);let h=i.axis.dot(s);c>=0&&h>=0&&h<=i.height&&(e.addVectors(i.base,s),r++);const u=(-x+n)/g;return s.copy(t),s.addScaledVector(this.direction,u),h=i.axis.dot(s),u>=0&&(0===r||c>u)&&h>=0&&h<=i.height&&(e.addVectors(i.base,s),r++),r&&a.copy(e),r?e:null}{const o=-x/g;s.copy(t),s.addScaledVector(this.direction,o);const r=i.axis.dot(s);if(o>=0&&r>=0&&r<=i.height)return e.addVectors(i.base,s),a.copy(e),e}}else if(0!==x){const o=-2*p/x;s.copy(t),s.addScaledVector(this.direction,o);const r=i.axis.dot(s);if(o>=0&&r>=0&&r<=i.height)return e.addVectors(i.base,s),a.copy(e),a}return null}}();const a=new e.Vector3;new e.Vector3;const o=new e.Vector3;new e.Vector3;const r=new e.Matrix4,n=new e.BoxBufferGeometry(2,2,2).toNonIndexed().attributes.position;class c{constructor(t,s,i,a,o){this.base=t||new e.Vector3,this.axis=s||new e.Vector3(0,1,0),this.axis.normalize(),this.height=i||1,this.radius0=a||0,this.radius1=o||0}static fromCapsule(t,s,i,a){if(s>a)return this.fromCapsule(i,a,t,s);const o=(new e.Vector3).subVectors(i,t);if(0===o.length())throw"Capsule height must not be zero";const r=(a-s)/o.length(),n=o.length()+r*(s-a),h=(new e.Vector3).copy(t).addScaledVector(o.normalize(),-r*s),u=Math.cos(Math.asin(r));return new c(h,o,n,s*u,a*u)}orthogonalProject(t,e){const s=a;s.subVectors(t,this.base);const i=s.lengthSq(),o=s.dot(this.axis),r=i-o*o,n=o-(r>0?Math.sqrt(r):0)*(this.radius0-this.radius1)/this.height;e.copy(this.axis).multiplyScalar(n).add(this.base)}copy(t){this.base=t.base.clone(),this.axis=t.axis.clone(),this.height=t.height,this.radius0=t.radius0,this.radius1=t.radius1}clone(){return(new c).copy(this)}empty(){return 0===this.height||0===this.radius0&&0===this.radius1}getBoundingBox(t){const s=this.base.clone(),i=new e.Vector3;i.set(Math.sqrt(1-this.axis.x*this.axis.x),Math.sqrt(1-this.axis.y*this.axis.y),Math.sqrt(1-this.axis.z*this.axis.z)),i.multiplyScalar(this.radius0);const a=new e.Box3((new e.Vector3).subVectors(s,i),(new e.Vector3).addVectors(s,i));i.divideScalar(this.radius0),i.multiplyScalar(this.radius1),s.addScaledVector(this.axis,this.height);const o=new e.Box3((new e.Vector3).subVectors(s,i),(new e.Vector3).addVectors(s,i));return a.union(o),null!=t&&t.copy(a),a}computeOptimisedBoundingCube(t){const e=n.clone(),s=Math.max(this.radius0,this.radius1);r.makeScale(s,this.height/2,s),e.applyMatrix4(r),a.set(0,1,0);const i=a.angleTo(this.axis);return a.cross(this.axis).normalize(),a.length()>0&&(r.makeRotationAxis(a,i),e.applyMatrix4(r)),a.copy(this.base).addScaledVector(this.axis,this.height/2).sub(t),r.makeTranslation(a.x,a.y,a.z),e.applyMatrix4(r),e.array}static computeOptimisedDownscalingBoundingCube(t,s,i,n,c,h){if(s>n)return this.computeOptimisedDownscalingBoundingCube(i,n,t,s,c,h);const u=new Float32Array([-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1]),d=[0,1,3,0,3,2,6,4,0,6,0,2,7,6,2,7,2,3,5,7,3,5,3,1,4,5,1,4,1,0,10,8,4,10,4,6,11,10,6,11,6,7,9,11,7,9,7,5,8,9,5,8,5,4,9,8,10,9,10,11],l=function(){const t=new Float32Array(3*d.length);for(let e=0;e<d.length;e++){const s=3*d[e];t[3*e]=u[s],t[3*e+1]=u[s+1],t[3*e+2]=u[s+2]}return t},p=(new e.Vector3).subVectors(i,t);if(0===p.length())throw"Capsule height must not be zero";const x=(n-s)/p.length();if(Math.abs(x)>=1/h*.9999){p.addVectors(t,i).multiplyScalar(.5);for(let t=0;t<u.length;t+=3)u[t]=p.x,u[t+1]=p.y,u[t+2]=p.z;return l()}if(Math.abs(x)>1)return this.computeOptimisedDownscalingBoundingCube(t,h*s,i,h*n,c,1);const g=Math.cos(Math.asin(x)),y=p.length()+x*(s-h*h*n),V=p.length()+x*(s-n);o.copy(t).addScaledVector(p.normalize(),-x*s);const f=n*g;let m=f>0?s*g/f:1;for(let t=0;t<12;t+=3)u[t]*=m,u[t+2]*=m;m=Math.cos(Math.asin(h*x))*n*h/f;for(let t=24;t<36;t+=3)u[t]*=m,u[t+2]*=m;const b=2*V/y-1;for(let t=12;t<24;t+=3)u[t+1]=b;const w=new e.BufferAttribute(l(),3);r.makeScale(f,y/2,f),w.applyMatrix4(r),a.set(0,1,0);const M=a.angleTo(p),S=a.dot(p);return a.cross(p).normalize(),a.length()>0?(r.makeRotationAxis(a,M),w.applyMatrix4(r)):S<0&&(r.makeRotationZ(Math.PI),w.applyMatrix4(r)),null!=c&&(a.copy(o).addScaledVector(p,y/2).sub(c),r.makeTranslation(a.x,a.y,a.z),w.applyMatrix4(r)),w.array}equals(t){return this.base.equals(t.base)&&this.axis.equals(t.axis)&&this.height===t.height&&this.radius0===t.radius0&&this.radius1===t.radius1}}return i.default.ConeFrustum=c,t.ConeFrustum=c,Object.defineProperty(t,"__esModule",{value:!0}),t}({},THREE);
