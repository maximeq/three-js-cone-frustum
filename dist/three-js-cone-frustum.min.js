var THREEConeFrustum=function(t,e){"use strict";e.Ray.prototype.intersectsConeFrustum=function(){const t=new e.Vector3,s=new e.Vector3,i=new e.Vector3;return function(e,o){null==o&&(o=s);const r=e.radius1-e.radius0,a=1+Math.pow(r/e.height,2),n=e.radius0*r/e.height;t.subVectors(this.origin,e.base);const c=t.dot(e.axis),h=t.dot(t),u=this.direction.dot(e.axis),d=this.direction.dot(t),l=this.direction.dot(this.direction),p=e.radius0*e.radius0+2*n*c+a*c*c-h,x=n*u+a*c*u-d,g=a*u*u-l;if(0!==g){const r=x*x-g*p;if(r<0)return null;if(0!==r){let a=0;const n=Math.sqrt(r),c=(-x-n)/g;i.copy(t),i.addScaledVector(this.direction,c);let h=e.axis.dot(i);c>=0&&h>=0&&h<=e.height&&(s.addVectors(e.base,i),a++);const u=(-x+n)/g;return i.copy(t),i.addScaledVector(this.direction,u),h=e.axis.dot(i),u>=0&&(0===a||c>u)&&h>=0&&h<=e.height&&(s.addVectors(e.base,i),a++),a&&o.copy(s),a?s:null}{const r=-x/g;i.copy(t),i.addScaledVector(this.direction,r);const a=e.axis.dot(i);if(r>=0&&a>=0&&a<=e.height)return s.addVectors(e.base,i),o.copy(s),s}}else if(0!==x){const r=-2*p/x;i.copy(t),i.addScaledVector(this.direction,r);const a=e.axis.dot(i);if(r>=0&&a>=0&&a<=e.height)return s.addVectors(e.base,i),o.copy(s),o}return null}}();const s=new e.Vector3;new e.Vector3;const i=new e.Vector3;new e.Vector3;const o=new e.Matrix4,r=new e.BoxBufferGeometry(2,2,2).toNonIndexed().attributes.position;class a{constructor(t,s,i,o,r){this.base=t||new e.Vector3,this.axis=s||new e.Vector3(0,1,0),this.axis.normalize(),this.height=i||1,this.radius0=o||0,this.radius1=r||0}static fromCapsule(t,s,i,o){if(s>o)return this.fromCapsule(i,o,t,s);const r=(new e.Vector3).subVectors(i,t);if(0===r.length())throw"Capsule height must not be zero";const n=(o-s)/r.length(),c=r.length()+n*(s-o),h=(new e.Vector3).copy(t).addScaledVector(r.normalize(),-n*s),u=Math.cos(Math.asin(n));return new a(h,r,c,s*u,o*u)}orthogonalProject(t,e){const i=s;i.subVectors(t,this.base);const o=i.lengthSq(),r=i.dot(this.axis),a=o-r*r,n=r-(a>0?Math.sqrt(a):0)*(this.radius0-this.radius1)/this.height;e.copy(this.axis).multiplyScalar(n).add(this.base)}copy(t){this.base=t.base.clone(),this.axis=t.axis.clone(),this.height=t.height,this.radius0=t.radius0,this.radius1=t.radius1}clone(){return(new a).copy(this)}empty(){return 0===this.height||0===this.radius0&&0===this.radius1}getBoundingBox(t){const s=this.base.clone(),i=new e.Vector3;i.set(Math.sqrt(1-this.axis.x*this.axis.x),Math.sqrt(1-this.axis.y*this.axis.y),Math.sqrt(1-this.axis.z*this.axis.z)),i.multiplyScalar(this.radius0);const o=new e.Box3((new e.Vector3).subVectors(s,i),(new e.Vector3).addVectors(s,i));i.divideScalar(this.radius0),i.multiplyScalar(this.radius1),s.addScaledVector(this.axis,this.height);const r=new e.Box3((new e.Vector3).subVectors(s,i),(new e.Vector3).addVectors(s,i));return o.union(r),null!=t&&t.copy(o),o}computeOptimisedBoundingCube(t){const e=r.clone(),i=Math.max(this.radius0,this.radius1);o.makeScale(i,this.height/2,i),e.applyMatrix4(o),s.set(0,1,0);const a=s.angleTo(this.axis);return s.cross(this.axis).normalize(),s.length()>0&&(o.makeRotationAxis(s,a),e.applyMatrix4(o)),s.copy(this.base).addScaledVector(this.axis,this.height/2).sub(t),o.makeTranslation(s.x,s.y,s.z),e.applyMatrix4(o),e.array}static computeOptimisedDownscalingBoundingCube(t,r,a,n,c,h){if(r>n)return this.computeOptimisedDownscalingBoundingCube(a,n,t,r,c,h);const u=new Float32Array([-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1]),d=[0,1,3,0,3,2,6,4,0,6,0,2,7,6,2,7,2,3,5,7,3,5,3,1,4,5,1,4,1,0,10,8,4,10,4,6,11,10,6,11,6,7,9,11,7,9,7,5,8,9,5,8,5,4,9,8,10,9,10,11],l=function(){const t=new Float32Array(3*d.length);for(let e=0;e<d.length;e++){const s=3*d[e];t[3*e]=u[s],t[3*e+1]=u[s+1],t[3*e+2]=u[s+2]}return t},p=(new e.Vector3).subVectors(a,t);if(0===p.length())throw"Capsule height must not be zero";const x=(n-r)/p.length();if(Math.abs(x)>=1/h*.9999){p.addVectors(t,a).multiplyScalar(.5);for(let t=0;t<u.length;t+=3)u[t]=p.x,u[t+1]=p.y,u[t+2]=p.z;return l()}if(Math.abs(x)>1)return this.computeOptimisedDownscalingBoundingCube(t,h*r,a,h*n,c,1);const g=Math.cos(Math.asin(x)),y=p.length()+x*(r-h*h*n),V=p.length()+x*(r-n);i.copy(t).addScaledVector(p.normalize(),-x*r);const b=n*g;let m=b>0?r*g/b:1;for(let t=0;t<12;t+=3)u[t]*=m,u[t+2]*=m;m=Math.cos(Math.asin(h*x))*n*h/b;for(let t=24;t<36;t+=3)u[t]*=m,u[t+2]*=m;const w=2*V/y-1;for(let t=12;t<24;t+=3)u[t+1]=w;const f=new e.BufferAttribute(l(),3);o.makeScale(b,y/2,b),f.applyMatrix4(o),s.set(0,1,0);const M=s.angleTo(p),S=s.dot(p);return s.cross(p).normalize(),s.length()>0?(o.makeRotationAxis(s,M),f.applyMatrix4(o)):S<0&&(o.makeRotationZ(Math.PI),f.applyMatrix4(o)),null!=c&&(s.copy(i).addScaledVector(p,y/2).sub(c),o.makeTranslation(s.x,s.y,s.z),f.applyMatrix4(o)),f.array}equals(t){return this.base.equals(t.base)&&this.axis.equals(t.axis)&&this.height===t.height&&this.radius0===t.radius0&&this.radius1===t.radius1}}const n="three-js-cone-frustum";var c,h;return c=n,h=130,THREE.REVISION!=h&&console.error(`${c} depends on THREE revision ${h}, but current revision is ${THREE.REVISION}.`),function(t,e,s){let i=`${t}: ${e} is duplicated. Your bundle includes ${e} twice. Please repair your bundle.`;try{if(void 0===THREE[e])return void(THREE[e]=s);if(THREE[e]!==s)throw i}catch(e){if(e===i)throw e;console.warn(`${t}: Duplication check unavailable.`+e)}}(n,"ConeFrustum",a),t.ConeFrustum=a,Object.defineProperty(t,"__esModule",{value:!0}),t}({},THREE);
